
       sd-id128.h provides APIs to process and generate 128-bit ID values.
       The 128-bit ID values processed and generated by these APIs are a
       generalization of OSF UUIDs as defined by RFC 4122[1] but use a
       simpler string format. These functions impose no structure on the
       used IDs, much unlike OSF UUIDs or Microsoft GUIDs, but are fully
       compatible with those types of IDs.
       See sd_id128_to_string(3), sd_id128_randomize(3) and
       sd_id128_get_machine(3) for more information about the implemented
       functions.
       A 128-bit ID is implemented as the following union type:
           typedef union sd_id128 {
                   uint8_t bytes[16];
                   uint64_t qwords[2];
           } sd_id128_t;
       This union type allows accessing the 128-bit ID as 16 separate bytes
       or two 64-bit words. It is generally safer to access the ID
       components by their 8-bit array to avoid endianness issues. This
       union is intended to be passed call-by-value (as opposed to
       call-by-reference) and may be directly manipulated by clients.
       A couple of macros are defined to denote and decode 128-bit IDs:
       SD_ID128_MAKE() may be used to denote a constant 128-bit ID in source
       code. A commonly used idiom is to assign a name to a 128-bit ID using
       this macro:
           #define SD_MESSAGE_COREDUMP SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)
       SD_ID128_NULL may be used to refer to the 128bit ID consisting of
       only NUL bytes.
       SD_ID128_MAKE_STR() is similar to SD_ID128_MAKE(), but creates a
       const char* expression that can be conveniently used in message
       formats and such:
           #include <stdio.h>
           #define SD_MESSAGE_COREDUMP_STR SD_ID128_MAKE_STR(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)
           int main(int argc, char **argv) {
                   puts("Match for coredumps: MESSAGE_ID=" SD_MESSAGE_COREDUMP_STR);
           }
       SD_ID128_CONST_STR() may be used to convert constant 128-bit IDs into
       constant strings for output. The following example code will output
       the string "fc2e22bc6ee647b6b90729ab34a250b1":
           int main(int argc, char *argv[]) {
                   puts("Match for coredumps: %s", SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP));
           }
       SD_ID128_FORMAT_STR() and SD_ID128_FORMAT_VAL() may be used to format
       a 128-bit ID in a printf(3) format string, as shown in the following
       example:
           int main(int argc, char *argv[]) {
                   sd_id128_t id;
                   id = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
                   printf("The ID encoded in this C file is " SD_ID128_FORMAT_STR ".\n", SD_ID128_FORMAT_VAL(id));
                   return 0;
           }
       Use sd_id128_equal() to compare two 128-bit IDs:
           int main(int argc, char *argv[]) {
                   sd_id128_t a, b, c;
                   a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
                   b = SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);
                   c = a;
                   assert(sd_id128_equal(a, c));
                   assert(!sd_id128_equal(a, b));
                   return 0;
           }
       Use sd_id128_is_null() to check if an 128bit ID consists of only NUL
       bytes:
           int main(int argc, char *argv[]) {
                   assert(sd_id128_is_null(SD_ID128_NULL));
           }
       Note that new, randomized IDs may be generated with journalctl(1)'s
       --new-id128 option.
