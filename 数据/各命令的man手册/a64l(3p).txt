
       These functions maintain numbers stored in radix-64 ASCII characters.
       This is a notation by which 32-bit integers can be represented by up
       to six characters; each character represents a digit in radix-64
       notation. If the type long contains more than 32 bits, only the low-
       order 32 bits shall be used for these operations.
       The characters used to represent digits are '.'  (dot) for 0, '/' for
       1, '0' through '9' for [2,11], 'A' through 'Z' for [12,37], and 'a'
       through 'z' for [38,63].
       The a64l() function shall take a pointer to a radix-64
       representation, in which the first digit is the least significant,
       and return the corresponding long value. If the string pointed to by
       s contains more than six characters, a64l() shall use the first six.
       If the first six characters of the string contain a null terminator,
       a64l() shall use only characters preceding the null terminator. The
       a64l() function shall scan the character string from left to right
       with the least significant digit on the left, decoding each character
       as a 6-bit radix-64 number. If the type long contains more than 32
       bits, the resulting value is sign-extended. The behavior of a64l() is
       unspecified if s is a null pointer or the string pointed to by s was
       not generated by a previous call to l64a().
       The l64a() function shall take a long argument and return a pointer
       to the corresponding radix-64 representation. The behavior of l64a()
       is unspecified if value is negative.
       The value returned by l64a() may be a pointer into a static buffer.
       Subsequent calls to l64a() may overwrite the buffer.
       The l64a() function need not be thread-safe.
